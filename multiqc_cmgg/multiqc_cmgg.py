#!/usr/bin/env python
"""MultiQC example plugin functions

We can add any custom Python functions here and call them
using the setuptools plugin hooks.
"""

from __future__ import print_function

from multiqc import config
import importlib_metadata
import logging
import yaml

# Initialise the main MultiQC logger
log = logging.getLogger("multiqc")


# Add default config options for the things that are used in MultiQC_NGI
def plugin_execution_start():
    """Code to execute after the config files and
    command line flags have been parsedself.

    This setuptools hook is the earliest that will be able
    to use custom command line flags.
    """

    # Plugin's version number defined in pyproject.toml:
    version = importlib_metadata.version("multiqc_cmgg")
    log.info(f"Running Example MultiQC Plugin v{version}")

    # Add to the main MultiQC config object.
    # User config files have already been loaded at this point
    #   so we check whether the value is already set. This is to avoid
    #   clobbering values that have been customised by users.

    if config.kwargs.get("disable_plugin", False):
        log.info("Plugin is disabled")
        return None

    log.debug("CMGG - Updating config")
    # Add module to module order
    config.module_order.extend(["sample_gender","coverage"])
     # Move module to the top
    config.top_modules.extend(["sample_gender","coverage"])

    # Convert the config_defaults.yaml and search_patterns.yaml to dictionairies (flatten yaml to dict)
    def load_yaml_as_flat_dict_one_level(file_path, sep='/'):
        def flatten_one_level(d, parent_key=''):
            items = {}
            for k, v in d.items():
                new_key = f"{parent_key}{sep}{k}" if parent_key else k
                if isinstance(v, dict):
                    items[new_key] = v  # Only flatten one level: keep inner dict as value
                else:
                    items[new_key] = v
            return items

        with open(file_path, 'r') as f:
            data = yaml.safe_load(f) or {}

        return flatten_one_level(data)

    # Load file and flatten
    searchpattern_yaml_dict = load_yaml_as_flat_dict_one_level('./multiqc_cmgg/search_patterns.yaml')
    config_yaml_dict = load_yaml_as_flat_dict_one_level('./multiqc_cmgg/config_defaults.yaml')

    # Insert search_pattern,yaml and config_yaml into multiqc config files. (may be redundant, but doesn't seem to work otherwise)
    for key in searchpattern_yaml_dict.keys():
        config.update_dict(config.sp,searchpattern_yaml_dict)
    for key in config_yaml_dict.keys():
        setattr(config,key,config_yaml_dict[key])
    
    # Some additional filename cleaning
    # config.fn_clean_exts.extend([".my_tool_extension", ".removeMetoo"])

    # Ignore some files generated by the custom pipeline
    # config.fn_ignore_paths.extend(
    #     [
    #         "*/my_awesome_pipeline/fake_news/*",
    #         "*/my_awesome_pipeline/red_herrings/*",
    #         "*/my_awesome_pipeline/noisy_data/*",
    #         "*/my_awesome_pipeline/rubbish/*",
    #     ]
    # )